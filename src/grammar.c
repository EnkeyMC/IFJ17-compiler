#include <stdarg.h>
#include <malloc.h>
#include <assert.h>

#include "grammar.h"
#include "token.h"

/// Get number of variable arguments
#define NUM_ARGS(...)  (sizeof((int[]){__VA_ARGS__})/sizeof(int))

/// Add epsilon rule to grammar, cleanup on failure
#define ADD_EPSILON_RULE(nt)  if (!grammar_add_epsilon_rule(curr_idx++, nt)) { grammar_free(); return false; }
/// Add rule to grammar, cleanup on failure
#define ADD_RULE(nt, ...) if (!grammar_add_rule(curr_idx++, nt, NUM_ARGS(__VA_ARGS__), __VA_ARGS__)) { grammar_free(); return false; }

/// Set table value, cleanup on failure
#define TABLE_SET(row, column, value) if (!sparse_table_set(grammar.LL_table, row, column - TERMINALS_START, value)) { grammar_free(); return false; }

static bool grammar_add_epsilon_rule(int idx, non_terminal_e nt) {
	assert(idx < NUM_OF_RULES);

	Rule* rule = (Rule*) malloc(sizeof(Rule));
	if (rule == NULL) {
		return false;
	}

	rule->production = (int*) malloc(sizeof(int));
	if (rule->production == NULL) {
		free(rule);
		return false;
	}

	rule->production[0] = END_OF_RULE;
	rule->for_nt = nt;

	grammar.rules[idx] = rule;

	return true;
}

static bool grammar_add_rule(int idx, non_terminal_e nt, int va_num, ...) {
	assert(idx < NUM_OF_RULES);

	Rule* rule = (Rule*) malloc(sizeof(Rule));
	if (rule == NULL) {
		return false;
	}

	rule->production = (int*) malloc(sizeof(int) * va_num + 1);
	if (rule->production == NULL) {
		free(rule);
		return false;
	}

	va_list va_args;
	va_start(va_args, va_num);
	int i;
	for (i = 0; i < va_num; i++) {
		rule->production[i] = va_arg(va_args, int);
	}

	rule->production[i] = END_OF_RULE;
	rule->for_nt = nt;

	va_end(va_args);

	grammar.rules[idx] = rule;

	return true;
}

static void rule_free(Rule* rule) {
	if (rule->production != NULL)
		free(rule->production);
	free(rule);
}

bool grammar_init() {
	// LL table init
	grammar.LL_table = sparse_table_init(NT_ENUM_SIZE, END_OF_TERMINALS - TERMINALS_START, 0);
	if (grammar.LL_table == NULL)
		return false;

	int curr_idx = 0;
	grammar.rules[curr_idx++] = NULL;  // First index needs to be empty

	ADD_RULE(NT_LINE, NT_STATEMENT, TOKEN_EOL, NT_LINE);
	ADD_EPSILON_RULE(NT_LINE);
	ADD_RULE(NT_STATEMENT, NT_INNER_STMT);
	ADD_RULE(NT_STATEMENT, NT_FUNC_DECL);
	ADD_RULE(NT_STATEMENT, NT_FUNC_DEF);
	ADD_RULE(NT_INNER_STMT, NT_VAR_DECL);
	ADD_RULE(NT_INNER_STMT, NT_ASSIGNMENT);
	ADD_RULE(NT_INNER_STMT, NT_IF_STMT);
	ADD_RULE(NT_INNER_STMT, NT_SCOPE_STMT);
	ADD_RULE(NT_INNER_STMT, NT_DO_STMT);
	ADD_RULE(NT_INNER_STMT, NT_FOR_STMT);
	ADD_RULE(NT_INNER_STMT, NT_PRINT_STMT);
	ADD_RULE(NT_INNER_STMT, NT_INPUT_STMT);
	ADD_EPSILON_RULE(NT_INNER_STMT);
	ADD_RULE(NT_STMT_SEQ, NT_INNER_STMT, TOKEN_EOL, NT_STMT_SEQ);
	ADD_EPSILON_RULE(NT_STMT_SEQ);
	ADD_RULE(NT_VAR_DECL, TOKEN_KW_DIM, NT_VAR_DECL_NEXT);
	ADD_RULE(NT_VAR_DECL, TOKEN_KW_STATIC, NT_VAR_DEF);
	ADD_RULE(NT_VAR_DECL_NEXT, NT_VAR_DEF);
	ADD_RULE(NT_VAR_DECL_NEXT, TOKEN_KW_SHARED, NT_VAR_DEF);
	ADD_RULE(NT_VAR_DEF, TOKEN_IDENTIFIER, TOKEN_KW_AS, NT_TYPE, NT_INIT_OPT);
	ADD_RULE(NT_INIT_OPT, TOKEN_EQUAL, NT_EXPRESSION);
	ADD_EPSILON_RULE(NT_INIT_OPT);
	ADD_RULE(NT_FUNC_DECL, TOKEN_KW_DECLARE, TOKEN_KW_FUNCTION, TOKEN_IDENTIFIER, TOKEN_LPAR, NT_PARAMS, TOKEN_RPAR, TOKEN_KW_AS, NT_TYPE);
	ADD_RULE(NT_TYPE, TOKEN_KW_INTEGER);
	ADD_RULE(NT_TYPE, TOKEN_KW_DOUBLE);
	ADD_RULE(NT_TYPE, TOKEN_STRING);
	ADD_RULE(NT_TYPE, TOKEN_KW_BOOLEAN);
	ADD_RULE(NT_FUNC_DEF, TOKEN_KW_FUNCTION, TOKEN_IDENTIFIER, TOKEN_LPAR, NT_PARAMS, TOKEN_RPAR, TOKEN_KW_AS, NT_TYPE, TOKEN_EOL, NT_FUNC_BODY, TOKEN_KW_END, TOKEN_KW_FUNCTION);
	ADD_RULE(NT_FUNC_BODY, NT_STMT_SEQ);
	ADD_RULE(NT_FUNC_BODY, TOKEN_KW_RETURN, NT_EXPRESSION, TOKEN_EOL, NT_FUNC_BODY);
	ADD_RULE(NT_PARAMS, NT_VAR_DEF, NT_PARAMS_NEXT);
	ADD_EPSILON_RULE(NT_PARAMS);
	ADD_RULE(NT_PARAMS_NEXT, TOKEN_COMMA, NT_VAR_DEF, NT_PARAMS_NEXT);
	ADD_EPSILON_RULE(NT_PARAMS_NEXT);
	ADD_RULE(NT_ASSIGNMENT, TOKEN_IDENTIFIER, NT_ASSIGN_OPERATOR, NT_EXPRESSION);
	ADD_RULE(NT_INPUT_STMT, TOKEN_KW_INPUT, TOKEN_IDENTIFIER);
	ADD_RULE(NT_PRINT_STMT, TOKEN_KW_PRINT, NT_EXPRESSION, TOKEN_SEMICOLON, NT_EXPRESSION_LIST);
	ADD_RULE(NT_EXPRESSION_LIST, NT_EXPRESSION, TOKEN_SEMICOLON, NT_EXPRESSION_LIST);
	ADD_EPSILON_RULE(NT_EXPRESSION_LIST);
	ADD_RULE(NT_SCOPE_STMT, TOKEN_KW_SCOPE, TOKEN_EOL, NT_STMT_SEQ, TOKEN_KW_END, TOKEN_KW_SCOPE);
	ADD_RULE(NT_IF_STMT, TOKEN_KW_IF, NT_EXPRESSION, TOKEN_KW_THEN, TOKEN_EOL, NT_STMT_SEQ, NT_IF_STMT_CONT);
	ADD_RULE(NT_IF_STMT_CONT, TOKEN_KW_END, TOKEN_KW_IF);
	ADD_RULE(NT_IF_STMT_CONT, TOKEN_KW_ELSE, TOKEN_EOL, NT_STMT_SEQ, TOKEN_KW_END, TOKEN_KW_IF);
	ADD_RULE(NT_IF_STMT_CONT, TOKEN_KW_ELSEIF, NT_EXPRESSION, TOKEN_KW_THEN, TOKEN_EOL, NT_STMT_SEQ, NT_IF_STMT_END);
	ADD_RULE(NT_IF_STMT_END, TOKEN_KW_END, TOKEN_KW_IF);
	ADD_RULE(NT_IF_STMT_END, TOKEN_KW_ELSE, TOKEN_EOL, NT_STMT_SEQ, TOKEN_KW_END, TOKEN_KW_IF);
	ADD_RULE(NT_DO_STMT, TOKEN_KW_DO, NT_DO_STMT_END);
	ADD_RULE(NT_DO_STMT_END, NT_TEST_TYPE, NT_EXPRESSION, TOKEN_EOL, NT_DO_BODY, TOKEN_KW_LOOP);
	ADD_RULE(NT_DO_STMT_END, TOKEN_EOL, NT_DO_BODY, TOKEN_KW_LOOP, NT_TEST_TYPE, NT_EXPRESSION);
	ADD_RULE(NT_TEST_TYPE, TOKEN_KW_WHILE);
	ADD_RULE(NT_TEST_TYPE, TOKEN_KW_UNTIL);
	ADD_RULE(NT_DO_BODY, NT_STMT_SEQ);
	ADD_RULE(NT_DO_BODY, TOKEN_KW_EXIT, TOKEN_KW_DO, TOKEN_EOL, NT_DO_BODY);
	ADD_RULE(NT_DO_BODY, TOKEN_KW_CONTINUE, TOKEN_KW_DO, TOKEN_EOL, NT_DO_BODY);
	ADD_RULE(NT_FOR_STMT, TOKEN_KW_FOR, TOKEN_IDENTIFIER, NT_TYPE_OPT, TOKEN_EQUAL, NT_EXPRESSION, TOKEN_KW_TO, NT_EXPRESSION, NT_STEP_OPT, TOKEN_EOL, NT_FOR_BODY, TOKEN_KW_NEXT, NT_ID_OPT, TOKEN_EOL);
	ADD_RULE(NT_FOR_BODY, NT_STMT_SEQ);
	ADD_RULE(NT_FOR_BODY, TOKEN_KW_EXIT, TOKEN_KW_FOR, TOKEN_EOL, NT_FOR_BODY);
	ADD_RULE(NT_FOR_BODY, TOKEN_KW_CONTINUE, TOKEN_KW_FOR, TOKEN_EOL, NT_FOR_BODY);
	ADD_RULE(NT_TYPE_OPT, TOKEN_KW_AS, NT_TYPE);
	ADD_EPSILON_RULE(NT_TYPE_OPT);
	ADD_RULE(NT_STEP_OPT, TOKEN_KW_STEP, NT_EXPRESSION);
	ADD_EPSILON_RULE(NT_STEP_OPT);
	ADD_RULE(NT_ID_OPT, TOKEN_IDENTIFIER);
	ADD_EPSILON_RULE(NT_ID_OPT);
	ADD_RULE(NT_ASSIGN_OPERATOR, TOKEN_EQUAL);
	ADD_RULE(NT_ASSIGN_OPERATOR, TOKEN_SUB_ASIGN);
	ADD_RULE(NT_ASSIGN_OPERATOR, TOKEN_ADD_ASIGN);
	ADD_RULE(NT_ASSIGN_OPERATOR, TOKEN_MUL_ASIGN);
	ADD_RULE(NT_ASSIGN_OPERATOR, TOKEN_DIVI_ASIGN);
	ADD_RULE(NT_ASSIGN_OPERATOR, TOKEN_DIVR_ASIGN);
	ADD_RULE(NT_EXPRESSION, TOKEN_IDENTIFIER);
	ADD_RULE(NT_EXPRESSION, TOKEN_INT);
	ADD_RULE(NT_EXPRESSION, TOKEN_REAL);
	ADD_RULE(NT_EXPRESSION, TOKEN_STRING);
	ADD_RULE(NT_EXPRESSION, TOKEN_KW_TRUE);
	ADD_RULE(NT_EXPRESSION, TOKEN_KW_FALSE);

	// LL table initialization
	TABLE_SET(NT_LINE, TOKEN_KW_DECLARE, 1);
	// TODO rest of the table

	return true;
}

void grammar_free() {
	for (int i = 0; i < NUM_OF_RULES; i++) {
		rule_free(grammar.rules[i]);
	}

	sparse_table_free(grammar.LL_table);
}
